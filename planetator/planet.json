{"generator":"float ridgedNoise(vec3 x) {\n    return 2.0 * (0.5 - 0.5 * abs(simplexNoise(x)));\n}\n\nfloat ridgedNoise(vec3 x, int n) {\n    float curr = ridgedNoise(x);\n    float sum = curr;\n    float fac = 1.0;\n    float total = 1.0;\n    \n    for (int i = 0; i < n; ++i) {\n        fac *= 0.5;\n        x *= 2.0;\n        sum += fac * ridgedNoise(x) * sum;\n        sum += curr;\n        total += fac;\n    }\n    \n    return sum / total;\n}\n\nfloat mountaineousness(vec3 x) {\n    float n = 0.5 + 0.5 * simplexNoise(x, 3, 0.5);\n    return smoothstep(0.2, 0.4, n * n);\n}\n\nfloat genMountain(vec3 x) {\n    float chain = ridgedNoise(x, 3);\n    chain *= 0.8 + 0.2 * simplexNoise(x * 7.0);\n    float detail = 0.1 * simplexNoise(x * 20.0, 8, 0.5);\n    return chain * (1.0 + detail);\n}\n \nfloat getHeight(vec3 position) {\n    float landbase = simplexNoise(position, 18, 0.55) - 0.15;\n    float mountain = mountaineousness(position * 4.0);\n    return landbase * (0.01 + 0.01 * mountain * genMountain(position * 20.0));\n}\n\nfloat getTemperature(vec3 position, float height) {\n    float temp = 1.0 - abs(position.z / radius);\n    temp += 0.1 * simplexNoise(position * 10.0);\n    temp -= height * 70.0;\n    return temp;\n}\n\nvoid generate(vec3 position, int depth)\n{\n    height = getHeight(position);\n    \n    float temp = getTemperature(position, height);\n    float wetness = 1.3 - 0.5 * temp;\n    wetness -= 1.5 * pow(0.5 + 0.5 * simplexNoise(position * 3.0, 2, 0.5), 3.0);\n    \n    float snow = smoothstep(0.7, 0.8, 1.0 - temp);\n    \n    surface = wetness * vec3(snow);\n    landRough = vec2(0.5 + height * pow(2.0, float(depth + 4)), 1.0);\n    height = max(height, 0.0);\n}","colorator":"vec3 sun = vec3(1.0, 0.0, 0.0);\n\nfloat debugOffset(float value, float ofs) {\n    return 0.5 + 1.0 * (value - ofs);\n}\n\nvec3 groundColor(vec3 pos) {\n    float bright = 0.8 + 0.1 * simplexNoise(pos);\n    float green = 0.4 + 0.1 * simplexNoise(pos + vec3(1.0));\n    float saturate = 0.5 + 0.1 * simplexNoise(pos + vec3(3.0));\n    \n    return bright * mix(vec3(1.0), vec3(1.0, green, 0.0), saturate);\n}\n\nvec3 color(vec3 normal, vec3 pos)\n{\n    float planetlight = max(0.0, dot(normalize(pos), sun));\n\n    if (landRough.x < 0.5) {        \n        return vec3(0.0, 0.1, 0.4) * planetlight;\n    }\n    \n    vec3 ice = vec3(1.0);\n    vec3 ground = groundColor(pos * 20.0);\n    \n    float slope = smoothstep(0.5, 1.0, dot(normalize(pos), normal));\n    \n    float light = planetlight * max(0.0, dot(normal.xyz, sun));\n    return vec3(1.0) * mix(ground, ice, slope * surface.x);\n}","select_channels":[["landRough",1],["surface",2]]}